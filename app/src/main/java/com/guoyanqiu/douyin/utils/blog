单例模式

RecyclerView之SnapHelper原理解析（一） https://blog.csdn.net/chunqiuwei/article/details/103187199

通过这篇文章可知只要重写RecyclerView.OnFlingListener接口，并将该接口的fling方法返回true就可以简单的将
RecyclerView作为ViewPager来使用，原理就是根据滚动的距离/recyerView的高度来计算滚动的当前页数。
下面就来说说Android 提供的另外一个库用PageSnapHelper是怎么工作的。

SnapHepler是什么？该组件本质上就是一个RecyclerView.OnFlingListener：
public abstract class SnapHelper extends RecyclerView.OnFlingListener

该类是个抽象类，有两个实现类LinearSnapHelper和PagerSnapHelper！关于PageSnapHelper，官方一句解释挺到位：
PagerSnapHelper can help achieve a similar behavior to {@link ViewPager}.，就是让RecyclerView能像ViewPager一样工作

所以RecyclerView之SnapHelper原理解析（一）费死了劲的写了怎么实现RecyclerView翻页滚动的效果，用PageSnapHelper两行代码的事儿：
 PagerSnapHelper pagerSnapHelper = new PagerSnapHelper();
 pagerSnapHelper.attachToRecyclerView(recyclerView);

但是PagerSnapHelper并没有告诉我们当前页是第几页，所以需要额外的处理:思
路就是预想知道当前页是第几页，只有等滚动结束的时候才可以知道。所以在监听滚动功能添加下面代码就可以：
      final PagerSnapHelper pagerSnapHelper = new PagerSnapHelper();
           pagerSnapHelper.attachToRecyclerView(recyclerView);
           recyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() {
               private int currentPage = -1;
               @Override
               public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) {
                   if(newState== RecyclerView.SCROLL_STATE_IDLE){//如果滚动结束
                       View snapView = pagerSnapHelper.findSnapView(linearLayoutManager);
                       int currentPageIndex = linearLayoutManager.getPosition(snapView);
                       if(currentPage!=currentPageIndex){//防止重复提示
                           currentPage = currentPageIndex;
                           Toast.makeText(MainActivity.this, "当前是第" + currentPageIndex + "页", Toast.LENGTH_SHORT).show();
                       }
                   }
               }
           });

  简单吧？核心代码仍然是两行：
  首先通过pagerSnapHelper.findSnapView(linearLayoutManager)来查到snapView
  其次通过linearLayoutManager的getPosition(view)方法知道当前view的位置，也就是currentPage的index。


 所以问题来了？findSnapView的作用是什么？PagerSnapHelper为什么可以实现ViewPager的效果？下面就来详细解密一下其内部原理。
  注意snap单词其中一个意思就是移动到某个位置！对于PageSnapHelper来说findSnapView就是距离ReclcyerView中间最近的那个view，比如以竖直滚动为例：

     public View findSnapView(RecyclerView.LayoutManager layoutManager) {
          if (layoutManager.canScrollVertically()) {
              return findCenterView(layoutManager, getVerticalHelper(layoutManager));
          } else if (layoutManager.canScrollHorizontally()) {
              return findCenterView(layoutManager, getHorizontalHelper(layoutManager));
          }
          return null;
      }

  private View findCenterView(RecyclerView.LayoutManager layoutManager,
            OrientationHelper helper) {
        int childCount = layoutManager.getChildCount();
        if (childCount == 0) {
            return null;
        }

        View closestChild = null;
        final int center;
        if (layoutManager.getClipToPadding()) {
            center = helper.getStartAfterPadding() + helper.getTotalSpace() / 2;
        } else {
            center = helper.getEnd() / 2;
        }
        int absClosest = Integer.MAX_VALUE;

        for (int i = 0; i < childCount; i++) {

            final View child = layoutManager.getChildAt(i);
            //childView的中心点
            int childCenter = helper.getDecoratedStart(child)
                    + (helper.getDecoratedMeasurement(child) / 2);
            int absDistance = Math.abs(childCenter - center);

            /** if child center is closer than previous closest, set it as closest  **/
            if (absDistance < absClosest) {
                absClosest = absDistance;
                closestChild = child;
            }
        }
        return closestChild;
    }

    所以对于竖直的RecyclerView来说findCenterView查找到的就是每个itemView的中心点距离RecyclerView最近的那个位置，比如有如下两种情况：


  刨根问底，从其父类SnapHelper来看，SnapHelper内置了RecyclerView.OnScrollListener，且当RecyclerView滚动结束的时候该listener会调用snapToTargetExistingView：
      @Override
                  public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
                      super.onScrollStateChanged(recyclerView, newState);
                      if (newState == RecyclerView.SCROLL_STATE_IDLE && mScrolled) {
                          mScrolled = false;
                          snapToTargetExistingView();
                      }
                  }


snapToTargetExistingView顾名思义,它的作用就是RecyclerView的itemView移动到目标位置，关于snapToTargetExistingView顾名思义的具体内容暂且按下不表，继续从本质看问题！

上文说到SnapHelper就是一个OnFlingListener，也即是使用ShapHelper来处理RecyclerView的惯性滑动，所以主要研究onFling方法
   public boolean onFling(int velocityX, int velocityY) {
        return (Math.abs(velocityY) > minFlingVelocity || Math.abs(velocityX) > minFlingVelocity)
                && snapFromFling(layoutManager, velocityX, velocityY);
    }

    闲话少说，看看snapFromFling方法：
      private boolean snapFromFling(@NonNull RecyclerView.LayoutManager layoutManager, int velocityX,
                int velocityY) {

            //根据惯性速度velocityY知道滚动停止时的位置Position
            int targetPosition = findTargetSnapPosition(layoutManager, velocityX, velocityY);

            //设置目标位置
            smoothScroller.setTargetPosition(targetPosition);
            //开始滚动
            layoutManager.startSmoothScroll(smoothScroller);
            return true;
        }


      可以看出SnapHelper处理惯性滚动逻辑很简单，就竖直滚动来说，首先根据layoutManager+ velocityY两个参数查找到惯性滚动
       要结束的位置targetPosition，如果找到的话就通过layoutManager.startSmoothScroll开始滚动的目标位置。这个targetPosition对应的view就是snapView.
       需要注意的是findTargetSnapPosition在SnapHelper是一个抽象方法，所以我们来看看PageSnapHelper是怎么实现的（以竖直滚动为例，提出了水平滚动的代码）：
         @Override
           public int findTargetSnapPosition(RecyclerView.LayoutManager layoutManager, int velocityX,
                   int velocityY) {

               final int itemCount = layoutManager.getItemCount();
                //findStartView获取的就是距离RecyclerView中心点最近的view
               View mStartMostChildView = findStartView(layoutManager, getVerticalHelper(layoutManager));

               //获取到中间位置
               final int centerPosition = layoutManager.getPosition(mStartMostChildView);

               //velocityY>0下一页 <0 上一页
               final boolean forwardDirection = velocityY > 0;
               //
               boolean reverseLayout = false;

               if ((layoutManager instanceof RecyclerView.SmoothScroller.ScrollVectorProvider)) {
                   RecyclerView.SmoothScroller.ScrollVectorProvider vectorProvider =
                           (RecyclerView.SmoothScroller.ScrollVectorProvider) layoutManager;
                   //判断滚动的方向
                   PointF vectorForEnd = vectorProvider.computeScrollVectorForPosition(itemCount - 1);
                   if (vectorForEnd != null) {
                       reverseLayout = vectorForEnd.x < 0 || vectorForEnd.y < 0;
                   }
               }
               return reverseLayout
                       ? (forwardDirection ? centerPosition - 1 : centerPosition)
                       : (forwardDirection ? centerPosition + 1 : centerPosition);
           }

**********************************findStartView**************************************

             private View findStartView(RecyclerView.LayoutManager layoutManager,
                       OrientationHelper helper) {
                   int childCount = layoutManager.getChildCount();
                   if (childCount == 0) {
                       return null;
                   }

                   View closestChild = null;
                   int startest = Integer.MAX_VALUE;

                   for (int i = 0; i < childCount; i++) {
                       final View child = layoutManager.getChildAt(i);
                       int childStart = helper.getDecoratedStart(child);

                       /** if child is more to start than previous closest, set it as closest  **/
                       if (childStart < startest) {
                           startest = childStart;
                           closestChild = child;
                       }
                   }
                   return closestChild;
               }
**********************computeScrollVectorForPosition以LinearLayoutManager为例*****************************

//判断滚动的方向targetPosition=itemCount-1
 public PointF computeScrollVectorForPosition(int targetPosition) {
        if (getChildCount() == 0) {
            return null;
        }
        //第一个child的位置
        final int firstChildPos = getPosition(getChildAt(0));
        //如果direction 1 则reverse
        final int direction = (targetPosition < firstChildPos )!= mShouldReverseLayout ? -1 : 1;
        if (mOrientation == HORIZONTAL) {
            return new PointF(direction, 0);
        } else {
            return new PointF(0, direction);
        }
    }

PagerSnapHelper的移动规则是每次滑动将距离中心位置最近的item移动到中心位置，如果你需要指定其他效果，就需要你自己实现这个方法，比如移动到左边距，移动到右边距等等